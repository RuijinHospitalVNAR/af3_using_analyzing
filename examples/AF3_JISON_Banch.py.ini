"""
AF3 JSON文件生成脚本
支持添加MSA输入路径设置（未配对和配对MSA）
自动将生成的JSON文件复制到8个文件夹（0-7）中

使用方法:
python script.py <fasta_file> <json_file> [name] [--unpaired unpaired_paths...] [--paired paired_paths...] [--per-seq-outdir DIR] [--chain-id ID] [--template TEMPLATE.json]

参数说明:
- fasta_file: 输入的FASTA文件路径
- json_file: 输出的JSON文件路径  
 - name: 项目名称（可选；省略时自动从FASTA首条序列头或文件名推断）
- --unpaired: 可选的未配对MSA文件路径列表，按序列顺序提供
- --paired: 可选的配对MSA文件路径列表，按序列顺序提供
 - --per-seq-outdir: 可选，为FASTA中每条序列分别生成单独JSON到该目录
 - --chain-id: 可选，为所有序列统一指定链ID（例如 A）
 - --template: 可选，提供一个模板JSON，脚本将按其字段风格与顺序输出

功能:
- 生成AlphaFold3格式的JSON文件
- 支持未配对和配对MSA路径设置
- 自动将JSON文件复制到8个文件夹（0-7）中
 - 支持从模板继承字段（如 modelSeeds/dialect/version）并进行漂亮缩进（indent=2）

示例:
python script.py input.fasta output.json my_protein --unpaired chain_A_unpaired.a3m chain_B_unpaired.a3m --paired chain_A_paired.a3m chain_B_paired.a3m
python script.py input.fasta output.json --unpaired chain_A_unpaired.a3m --paired chain_A_paired.a3m
python script.py input.fasta output.json my_protein --per-seq-outdir outputs/
python script.py input.fasta output.json my_protein --chain-id A
python script.py input.fasta output.json --template input_template.json
"""
import json
import sys
import os
import shutil

def _chain_label(n: int) -> str:
    """Convert 1->A, 26->Z, 27->AA, etc., for chain labeling."""
    s = []
    while n > 0:
        n, r = divmod(n - 1, 26)
        s.append(chr(ord('A') + r))
    return ''.join(reversed(s))

def _sanitize_filename(name: str) -> str:
    """Make a filename-safe token from a header or id."""
    safe = ''.join(c if c.isalnum() or c in ('-', '_', '.') else '_' for c in name)
    # Collapse consecutive underscores
    while '__' in safe:
        safe = safe.replace('__', '_')
    return safe.strip('_') or 'seq'

def parse_fasta(file_path, unpaired_msa_paths=None, paired_msa_paths=None, forced_chain_id=None):
    "解析你的FASTA，返回序列信息"
    sequences = []
    with open(file_path, "r") as file:
        lines = file.readlines()

    current_sequence = {}
    sequence_count = 0  # 跟踪序列的顺序
    for line in lines:
        line = line.strip()
        if not line:
            continue
        if line.startswith(">"):
            if current_sequence:
                sequences.append(current_sequence)
            current_sequence = {"type": "protein", "sequence": ""}
            sequence_count += 1
            # 根据参数设置链ID；若未指定则按序列顺序分配动态链ID: A..Z, AA.. 等
            if forced_chain_id:
                current_sequence["id"] = forced_chain_id
            else:
                current_sequence["id"] = _chain_label(sequence_count)
            # 保存FASTA头（去掉前导>），用于命名
            header_text = line[1:].strip()
            current_sequence["header"] = header_text
            
            # 添加未配对MSA（如果提供）
            if unpaired_msa_paths:
                if len(unpaired_msa_paths) == 1:
                    current_sequence["unpairedMsa"] = unpaired_msa_paths[0]
                elif sequence_count <= len(unpaired_msa_paths):
                    current_sequence["unpairedMsa"] = unpaired_msa_paths[sequence_count - 1]
            
            # 添加配对MSA（如果提供）
            if paired_msa_paths:
                if len(paired_msa_paths) == 1:
                    current_sequence["pairedMsa"] = paired_msa_paths[0]
                elif sequence_count <= len(paired_msa_paths):
                    current_sequence["pairedMsa"] = paired_msa_paths[sequence_count - 1]
            
            # 预置模板字段为空数组（若需要可后续填充）
            current_sequence.setdefault("templates", [])
        else:
            # 若尚未遇到第一个FASTA头，则跳过游离序列行
            if not current_sequence:
                continue
            current_sequence["sequence"] += line
    if current_sequence:
        sequences.append(current_sequence)
    return sequences

def create_json(sequences, output_file, name, template=None):
    """生成JSON文件（按模板字段与顺序漂亮输出 indent=2，并省略空字段）"""

    # 从模板继承顶层字段
    model_seeds = None
    dialect = None
    version = None
    if isinstance(template, dict):
        model_seeds = template.get("modelSeeds")
        dialect = template.get("dialect")
        version = template.get("version")
        # 若未提供 name，尝试用模板 name
        if not name:
            name = template.get("name")

    # 组装顶层数据，保持插入顺序: name, modelSeeds, sequences, dialect, version
    data = {}
    data["name"] = name or ""
    data["modelSeeds"] = model_seeds if model_seeds is not None else [2704]

    sequences_out = []
    for seq in sequences:
        protein = {
            "id": seq["id"],
            "sequence": seq["sequence"],
        }
        # 仅当有值时包含可选字段
        if seq.get("unpairedMsa"):
            protein["unpairedMsa"] = seq.get("unpairedMsa")
        if seq.get("pairedMsa"):
            protein["pairedMsa"] = seq.get("pairedMsa")
        if seq.get("templates"):
            templates_val = seq.get("templates")
            if isinstance(templates_val, list) and len(templates_val) > 0:
                protein["templates"] = templates_val
        sequences_out.append({"protein": protein})

    data["sequences"] = sequences_out
    data["dialect"] = dialect if dialect is not None else "alphafold3"
    data["version"] = version if version is not None else 2

    # 漂亮打印，indent=2
    rendered = json.dumps(data, ensure_ascii=False, indent=2)
    # 将单元素的 modelSeeds 保持为单行: "modelSeeds": [2704]
    try:
        seeds_val = data.get("modelSeeds")
        if isinstance(seeds_val, list) and len(seeds_val) == 1:
            lines = rendered.splitlines()
            new_lines = []
            i = 0
            while i < len(lines):
                line = lines[i]
                if line.strip().startswith("\"modelSeeds\"") and line.strip().endswith("["):
                    # 记录前导空格与是否尾随逗号
                    leading_spaces = line[:len(line) - len(line.lstrip(' '))]
                    # 下一行应为数字，再下一行为 ] 或 ],
                    if i + 2 < len(lines):
                        num_line = lines[i + 1].strip().rstrip(',')
                        close_line = lines[i + 2].strip()
                        # 判断逗号是否存在于关闭行
                        trailing_comma = close_line.endswith(',')
                        # 提取数字字符串
                        seed_text = num_line
                        # 写入单行
                        inline = f"{leading_spaces}\"modelSeeds\": [{seed_text}]{',' if trailing_comma else ''}"
                        new_lines.append(inline)
                        i += 3
                        continue
                new_lines.append(line)
                i += 1
            rendered = "\n".join(new_lines)
    except Exception:
        pass
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(rendered)
    print(f"JSON file saved to {output_file}")
    return output_file

def organize_json_files(json_file, base_output_dir):
    """将JSON文件复制到8个文件夹（0-7）中"""
    # 获取JSON文件的目录和文件名
    json_dir = os.path.dirname(json_file)
    json_filename = os.path.basename(json_file)
    
    # 创建8个文件夹
    for i in range(8):
        folder_path = os.path.join(base_output_dir, str(i))
        os.makedirs(folder_path, exist_ok=True)
        
        # 复制JSON文件到每个文件夹
        dest_path = os.path.join(folder_path, json_filename)
        shutil.copy2(json_file, dest_path)
        print(f"复制到文件夹 {i}: {dest_path}")
    
    print(f"JSON文件已成功复制到8个文件夹中")

# 主程序
if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python script.py <fasta_file> <json_file> [name] [--unpaired unpaired_paths...] [--paired paired_paths...] [--per-seq-outdir DIR] [--chain-id ID]")
        print("Example: python script.py input.fasta output.json my_protein --unpaired chain_A_unpaired.a3m chain_B_unpaired.a3m --paired chain_A_paired.a3m chain_B_paired.a3m")
        print("Example: python script.py input.fasta output.json my_protein --per-seq-outdir outputs/")
        print("Example: python script.py input.fasta output.json my_protein --chain-id A")
        sys.exit(1)
    
    fasta_file = sys.argv[1]  # 输入的FASTA文件
    json_file = sys.argv[2]   # 输出的JSON文件
    # name 可选：若缺省则延后从FASTA头或文件名推断
    name = None
    
    # 解析命令行参数
    unpaired_msa_paths = []
    paired_msa_paths = []
    per_seq_outdir = None
    chain_id = None
    template_path = None
    current_mode = None
    # 若提供了第三个位置参数且不是选项，则当作 name
    start_idx = 3 if len(sys.argv) > 3 and not sys.argv[3].startswith("--") else 2
    if start_idx == 3:
        name = sys.argv[3]
    args = sys.argv[start_idx+1:]
    i = 0
    while i < len(args):
        arg = args[i]
        if arg == "--unpaired":
            current_mode = "unpaired"
            i += 1
            continue
        if arg == "--paired" or arg == "--paird":  # 兼容常见拼写错误
            current_mode = "paired"
            i += 1
            continue
        if arg == "--per-seq-outdir":
            if i + 1 >= len(args):
                print("--per-seq-outdir 需要一个目录参数")
                sys.exit(1)
            per_seq_outdir = args[i + 1]
            i += 2
            continue
        if arg == "--chain-id":
            if i + 1 >= len(args):
                print("--chain-id 需要一个ID参数，例如 A")
                sys.exit(1)
            chain_id = args[i + 1]
            i += 2
            continue
        if arg == "--template":
            if i + 1 >= len(args):
                print("--template 需要一个模板JSON文件路径")
                sys.exit(1)
            template_path = args[i + 1]
            i += 2
            continue
        if current_mode == "unpaired":
            unpaired_msa_paths.append(arg)
            i += 1
            continue
        if current_mode == "paired":
            paired_msa_paths.append(arg)
            i += 1
            continue
        print(f"未知参数: {arg}")
        print("使用 --unpaired 或 --paired 来指定MSA类型 (支持 --paird 作为别名)，或 --per-seq-outdir DIR，或 --chain-id ID，或 --template TEMPLATE.json")
        sys.exit(1)
    
    # 如果没有提供任何MSA路径，设为None
    unpaired_msa_paths = unpaired_msa_paths if unpaired_msa_paths else None
    paired_msa_paths = paired_msa_paths if paired_msa_paths else None
    
    sequences = parse_fasta(fasta_file, unpaired_msa_paths, paired_msa_paths, forced_chain_id=chain_id)
    template_obj = None
    if template_path:
        try:
            with open(template_path, 'r', encoding='utf-8') as tf:
                template_obj = json.load(tf)
        except Exception as e:
            print(f"读取模板失败: {e}")
            sys.exit(1)
    # 若未显式提供 name，则从首条序列头获取，否则退回到FASTA文件名无后缀
    if not name:
        if sequences and sequences[0].get("header"):
            name = sequences[0]["header"].split()[0]
        else:
            name = os.path.splitext(os.path.basename(fasta_file))[0]
    # 如果指定了每序列输出目录，则为每条序列各生成一个JSON
    if per_seq_outdir:
        os.makedirs(per_seq_outdir, exist_ok=True)
        base_name = os.path.splitext(os.path.basename(json_file))[0]
        for idx, seq in enumerate(sequences, start=1):
            label = seq.get("id", str(idx))
            header_token = _sanitize_filename(seq.get("header", label).split()[0])
            out_name = f"{base_name}_{header_token or label}.json"
            out_path = os.path.join(per_seq_outdir, out_name)
            # 每个JSON的name使用头部token（若无则用label）
            per_seq_name = header_token or label
            created = create_json([seq], out_path, per_seq_name, template=template_obj)
            # 将每个JSON复制到8个文件夹中
            organize_json_files(created, per_seq_outdir)
    else:
        created_json_file = create_json(sequences, json_file, name, template=template_obj)
        # 将JSON文件复制到8个文件夹中
        base_output_dir = os.path.dirname(json_file) if os.path.dirname(json_file) else "."
        organize_json_files(created_json_file, base_output_dir)

